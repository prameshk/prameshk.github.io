\documentclass[letterpaper,11pt,twoside]{article}

\usepackage[left=1in, right=1in, bottom=1.25in, top=1.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{setspace}
%\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\allowdisplaybreaks
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage[mathscr]{euscript}
\usepackage{latexsym,bbm,xspace,graphicx,float,mathtools,mathdots,xspace}
\usepackage{enumitem}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{bm}
\usepackage[backref, colorlinks,citecolor=blue,linkcolor=magenta,bookmarks=true]{hyperref}
\usepackage[nameinlink]{cleveref}

% tikz
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{tikz}

\usepackage{tablefootnote}

\fancypagestyle{plain}{%
\fancyhf{} % clear all header and footer fields
\fancyfoot[C]{\textbf{\thepage}} % except the center
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{assumption}{Assumption}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Conjecture}
\newtheorem{proposition}{Proposition}
\newtheorem{observation}{Observation}
\newtheorem{claim}{Claim}
\newtheorem{property}{Property}
\newtheorem{op}{Open Problem}
\newtheorem{problem}{Problem}
\newtheorem{question}{Question}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{sketch}{Sketch}
\newtheorem{idea}{Idea}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newtheoremstyle{restate}{}{}{\itshape}{}{\bfseries}{~(restated).}{.5em}{\thmnote{#3}}
\theoremstyle{restate}
\newtheorem*{restate}{}



\crefname{theorem}{Theorem}{Theorems}
\crefname{assumption}{Assumption}{Assumptions}
\crefname{corollary}{Corollary}{Corollaries}
\crefname{lemma}{Lemma}{Lemmas}
\crefname{conjecture}{Conjecture}{Conjectures}
\crefname{proposition}{Proposition}{Propositions}
\crefname{observation}{Observation}{Observations}
\crefname{claim}{Claim}{Claims}
\crefname{property}{Property}{Properties}
\crefname{op}{Open Problem}{Open Problems}
\crefname{problem}{Problem}{Problems}
\crefname{question}{Question}{Questions}

% \crefname{fact}{Fact}{Facts}

\crefname{definition}{Definition}{Definitions}
\crefname{example}{Example}{Examples}
\crefname{sketch}{Sketch}{Sketches}
\crefname{idea}{Idea}{Ideas}

% \crefname{condition}{Condition}{Conditions}

\crefname{remark}{Remark}{Remarks}



\crefname{equation}{Equation}{Equations}
\crefname{figure}{Figure}{Figures}
\crefname{table}{Table}{Tables}



%%%%%%%%%%%%%%%%%%%%%%%%%%
% GENERAL-PURPOSE MACROS %
%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\uth}{\bigskip \bigskip {\huge {\red{UP TO HERE}} \bigskip \bigskip}}
\newcommand{\ignore}[1]{}
\newcommand{\eps}{\varepsilon}
\newcommand{\simple}{\mathrm{simple}}
\newcommand{\E}{\operatorname{{\bf E}}}
\newcommand{\Ex}{\mathop{{\bf E}\/}}
\renewcommand{\Pr}{\operatorname{{\bf Pr}}}
\newcommand{\Prx}{\mathop{{\bf Pr}\/}}
\newcommand{\Var}{\operatorname{{\bf Var}}}
\newcommand{\Varx}{\mathop{{\bf Var}\/}}
\newcommand{\tO}{\tilde{O}}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\rZ}{\mathcal{Z}}

\DeclareMathOperator\erf{erf}

\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\bcalZ}{\bm{\mathcal{Z}}}
\newcommand{\bx}{\bm{x}}
\newcommand{\by}{\bm{y}}
\newcommand{\bxi}{\bm{\xi}}

%%%%%%%%%%%%%%%%%%
% NUMBER SYSTEMS %
%%%%%%%%%%%%%%%%%%
\newcommand{\R}{\mathbb R}
\newcommand{\RR}{\R_{\geq 0}}
\newcommand{\C}{\mathbb C}
\newcommand{\N}{\mathbb N}
\newcommand{\NN}{\N_{\geq 1}}
\newcommand{\Z}{\mathbb Z}

\renewcommand{\i}{\mathbf{i}}   % for complex numbers
\renewcommand{\d}{\mathrm{d}}   % for integrals
\newcommand{\lhs}{\mathrm{LHS}} % for inequalities
\newcommand{\rhs}{\mathrm{RHS}} % for inequalities
\newcommand{\supp}{\mathrm{supp}}
\renewcommand{\hat}[1]{\widehat{#1}}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\sig}{\mathrm{sig}}

\newcommand{\comment}[1]{}

% Define colors
\def\colorful{1}
\ifnum\colorful=1
\newcommand{\violet}[1]{{\color{violet}{#1}}}
\newcommand{\orange}[1]{{\color{orange}{#1}}}
\newcommand{\blue}[1]{{{\color{blue}#1}}}
\newcommand{\red}[1]{{\color{red} {#1}}}
\newcommand{\green}[1]{{\color{green} {#1}}}
\newcommand{\pink}[1]{{\color{pink}{#1}}}
\newcommand{\gray}[1]{{\color{gray}{#1}}}
\fi
\ifnum\colorful=0
\newcommand{\violet}[1]{{{#1}}}
\newcommand{\orange}[1]{{{#1}}}
\newcommand{\blue}[1]{{{#1}}}
\newcommand{\red}[1]{{{#1}}}
\newcommand{\green}[1]{{{#1}}}
\newcommand{\gray}[1]{{{#1}}}
\fi

\title{Homework 5}
% \author{Tim Randolph}
\date{COMS W3261, Summer B 2021}

\begin{document}

\maketitle

This homework is due \textbf{Monday, 8/2/2021, at 11:59PM EST}. Submit to GradeScope (course code: X3JEX4).

Grading policy reminder: \LaTeX~is preferred, but neatly typed or handwritten solutions are acceptable. Your TAs may dock points for indecipherable writing. Proofs should be complete; that is, include enough information that a reader can clearly tell that the argument is rigorous.

The tool \url{http://madebyevan.com/fsm/} may be useful for drawing finite state machines.

If a question is ambiguous, please state your assumptions. This way, we can give you credit for correct work. (Even better, post on Ed so that we can resolve the ambiguity.)

\clearpage
\section{Problem 1 (15 points)}

Use the context-free pumping lemma to prove that the following languages are not context-free. (Recall that the CFPL has the form "In any context-free language, all sufficiently long strings have some decomposition that satisfies three properties". To show that a language is not context-free, we need to contradict this statement; i.e., show that "In this particular language, there exists at least one long string such that \emph{no} decomposition of this string satisfies all three properties.")
\begin{enumerate}
    \item (5 points).
    \[
        L_1 = \{a^nb^na^nb^n \; | \; n \geq 1\}.
    \]
    
    \item (10 points).
    \[
        L_2 = \{a^ib^jc^k \; | \; i, j, k \geq 1; ij = k\}.
    \]
\end{enumerate}

\clearpage
\section{Problem 2 (8 points)}
Provide \emph{implementation-level descriptions} of Turing Machines that recognize the following languages.

(Recall that an implementation-level description is less detailed than a \emph{formal description}, in which we specify every state, transition function, and so on. You do not need to specify specific states or the transition function for this question. An implementation-level description is more detailed than a \emph{high-level description}, in which we describe an algorithm but ignore all details of how we move the machine head or manage storage on the tape. For this question, you should describe in prose how the TM moves its head around and manages memory. Answers should be a few paragraphs (certainly more than one sentence and less than two pages.))

(Example answer for the language $\{w\#w^R : w \in \{0,1\}^*\}$: 
First, we read the input string from left to right and ensure it contains the $\#$ symbol. We reject if it does not. Then, beginning at the hash symbol, we shuttle back and forth between the two substrings on either side. Every time we go to the left, we cross out and remember the first uncrossed symbol we come to. If it matches the first uncrossed symbol on the right, we cross out this symbol also and continue. If it does not match, or if there are no more uncrossed symbols on the right, we reject. Once we have completed this procedure for all symbols on the left substring, we accept if and only if we have crossed out all symbols on the right substring.)

\begin{enumerate}
    \item (4 points).
    \[
        L_3 = \{0^n1^n2^n \; | \; n \geq 1\}.
    \]
    
    \item (4 points).
    \[
        L_4 = \{a^nb^{n^2} \; | \; i \geq 1\}.
    \]
\end{enumerate}

\clearpage
\section{Problem 3 (12 points)}
Provide \emph{high-level descriptions} of Turing Machines that recognize the following languages. 

(Recall that a high-level description is an algorithm for a Turing Machine described in prose, ignoring implementation details such as the way information is encoded or where the head needs to move. However, your TM's behavior should still be \emph{precisely specified}: it should be clear what the Turing Machine does in every case. These answers should be on the order of a few sentences.)

(Example for the language $\{\langle G\rangle \; | \; \langle G \rangle \text{ encodes a connected graph.}\}$: First, check to see if the input encodes a graph and reject if not. Then, begin a list with an arbitrary vertex $v$. Add every neighbor of $v$ to the list, then every neighbor's neighbor, and so on. Repeat this process until no new vertices are added and accept if the list contains every vertex.) 

\begin{enumerate}
    \item (4 points).
    The Fibonacci sequence $F$ begins by defining $F_0 = 0$ and $F_1 = 1$, and then recursively defines $F_i$ for all $i \geq 2$ as $F_i = F_{i-1} + F_{i-2}$.
    \[
        L_5 = \{w \; | \; w \text{ is a number in the Fibonacci sequence}\}.
    \]
    
    \item (4 points). Let $D$ be any DFA.
    \[
        L_D = \{w \; | \; D \text{ accepts the input string } w\}.
    \]
    
    \item (4 points). The following language consists of strings over $\{0,1\}$ and the symbols $\cup$, $^*$, $^+$, etc., that we usually use to write down regular expressions. 
    \[
        L_R = \{w \; | \; w \text{ is a well-defined regular expression over $\{0,1\}$}\}.
    \]
\end{enumerate}

\clearpage
\section{Problem 4 (Extra credit, up to 10 points)}
\begin{enumerate}
    \item (2 points). $P$ and $NP$ refer to classes of languages that we will define next week. The question of whether $P = NP$ is a famous unresolved question in theoretical computer science.
    
    Consider the language $L_6$ defined as follows. 
    \[
    L_6 = 
        \begin{cases}
            \{0\} \text{ if $P \neq NP$ } \\
            \{1\} \text{ if $P = NP$ }.
        \end{cases}
    \]
    Is this language decidable? (Hint: you don't need to know what $P$ and $NP$ are to answer this question.)
    
    \item (3 points). Give a high-level description of a Turing machine that recognizes the following language.
    \[
    L_7 = \{\langle M\rangle \; | \; \langle M\rangle \text{ encodes a TM that accepts the input string `ACCEPT ME'}\}.
    \]
    
    \item (1 point). In the previous part, you showed that $L_7$ was Turing-recognizable. Why is it harder to show that $L_7$ is decidable?
    
    \item (4 points). Recall that an \emph{enumerator} is a Turing Machine with an attached printer that can print the contents of its tape at any point. The language of an enumerator is the set of all strings that it prints. Let $G$ be a context-free grammar. Give a high-level description of an enumerator that writes down every string in the language of $G$.
\end{enumerate}


\end{document}